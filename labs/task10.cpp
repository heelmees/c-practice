/*
`std::vector` в C++ — это динамический массив переменной длины, 
который может изменять свой размер во время выполнения программы. 
Он является частью стандартной библиотеки шаблонов (STL) и обеспечивает 
удобный способ работы с массивами.


Внутренне `std::vector` устроен следующим образом:

- **Данные**: Вектор хранит свои элементы в непрерывном блоке памяти, 
что позволяет быстро осуществлять доступ к элементам по индексу, 
так же как и в обычном массиве.

(вопрос №1, №2 capacity и size)
- **Емкость (Capacity)**: Это количество элементов, 
которое вектор может вместить без необходимости выделения нового блока памяти. 
Когда вектор достигает своей текущей емкости и требуется добавление новых элементов, 
он автоматически расширяется, выделяя больший блок памяти и копируя существующие элементы в новое место.

- **Размер (Size)**: Текущее количество элементов, содержащихся в векторе. 
Размер всегда меньше или равен емкости.


Когда происходит добавление элементов в `std::vector`, он работает следующим образом:
1. Если текущий размер вектора меньше его емкости, новый элемент просто добавляется в конец вектора.
2. Если размер вектора равен его емкости, то вектор должен расшириться:
   - Выделяется новый блок памяти, обычно в 2 раза больше текущей емкости.
   - Существующие элементы копируются или перемещаются в новый блок памяти.
   - Новый элемент добавляется после существующих элементов.
   - Старый блок памяти освобождается.

Такая стратегия выделения памяти позволяет оптимизировать количество операций выделения памяти и копирования при последовательном добавлении элементов, но может привести к временному использованию большего количества памяти, чем необходимо для хранения элементов.

Основные операции, которые можно выполнять с `std::vector`, включают добавление, удаление и доступ к элементам, а также получение размера и емкости вектора.
*/

#include <vector>
#include <iostream>

void printVector(std::vector<int> v) {
   for (int elem: v) {
      std::cout << elem << " ";
   }
   std::cout << std::endl;
}

int main() {
   //(вопрос №3)
   // Объявляем вектор: тип элемента int (указывается с помощью угловых скобок <>), размер = 2, ёмкость = 2
   std::vector<int> v(2);
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;

   // Объявляем нулевой вектор, размер = 0, ёмкость = 0
   std::vector<int> v2;
   std::cout << "Размер: " << v2.size() << " Ёмкость: " << v2.capacity() << std::endl;
   // Резервируем место под два элемента, размер = 0, ёмкость = 2
   //(вопрос №2)
   v2.reserve(2);
   std::cout << "Размер: " << v2.size() << " Ёмкость: " << v2.capacity() << std::endl;

   //(вопрос №5)
   // Оператор [] не выполняет проверку границ. При обращении к элементу за пределами размера 
   // вектора поведение будет неопределённым, что может привести к ошибкам доступа к памяти.
   // Например v[10] - поведение непредсказуемо.
   v[0] = 0;
   // Метод at() выполняет проверку границ индекса. 
   // Если указанный индекс выходит за пределы диапазона текущего размера вектора, 
   // at() выбросит исключение std::out_of_range.
   // Например v.at(10) выбросит исключение.
   v.at(1) = 1;
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;
   //(вопрос №4)
   // push_back добавляет в конец вектора элемент, при необходимости "расширяет" вектор, 
   // т.е. выделяет новую область памяти (в 2 раза больше) и копирует содержимое исходного вектора
   v.push_back(2);  // Ёмкость вектора увеличится в два раза, размер на 1
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;
   v.push_back(3);  // Ёмкость вектора не изменится (есть место для элемента), размер увеличится на 1
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;
   
   //(вопрос №2)
   std::cout << "shrink_to_fit, уменьшение ёмкости до текущего размера" << std::endl;
   v.push_back(4); 
   // Ёмкость удвоилась = 8, размер = 5
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;
   v.shrink_to_fit();
   // Ёмкость стала равна размеру = 5
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;

   //(вопрос №2)
   std::cout << "resize, изменение размера вектора в обе стороны" << std::endl;
   v.resize(6, 0);
   // Ёмкость удвоилась = 10, размер = 6
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;
   v.resize(4);
   // Ёмкость = 10,  размер = 4
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;

   //(вопрос №4)
   std::cout << "erase, удаление элементов контейнера" << std::endl;
   printVector(v);
   v.erase(v.begin() + 1, v.begin() + 3);
   printVector(v);
   // Ёмкость осталась = 10, размер = 2 (удалили два элемента, первый и второй)
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;

   //(вопрос №4)
   std::cout << "insert, вставка элементов в контейнер" << std::endl;
   printVector(v);
   v.insert(v.begin() + 1, 1);
   printVector(v);
   // Ёмкость осталась = 10, размер = 3 (вставилось 1 перед первым элементом)
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;
   
   //(вопрос №4)
   std::cout << "clear, очистка контейнера" << std::endl;
   printVector(v);
   v.clear();
   printVector(v);
   // Ёмкость осталась = 10, размер = 0 (удалились все элементы)
   std::cout << "Размер: " << v.size() << " Ёмкость: " << v.capacity() << std::endl;

   return 0;
}
